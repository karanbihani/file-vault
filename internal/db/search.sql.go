// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: search.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const searchFiles = `-- name: SearchFiles :many
SELECT
    uf.id,
    uf.filename,
    uf.mime_type,
    uf.upload_date,
    pf.size_bytes,
    u.email as owner_email
FROM
    user_files uf
JOIN
    users u ON uf.owner_id = u.id
JOIN
    physical_files pf ON uf.physical_file_id = pf.id
WHERE
    (
        $1::boolean OR
        uf.owner_id = $2::bigint OR
        EXISTS (
            SELECT 1 FROM file_shares_to_users fstu
            WHERE fstu.user_file_id = uf.id AND fstu.shared_with_user_id = $2::bigint
        )
    )
AND
    (uf.filename ILIKE '%' || $3 || '%' OR $3 IS NULL)
AND
    (uf.mime_type = $4 OR $4 IS NULL)
AND
    (pf.size_bytes >= $5 OR $5 IS NULL)
AND
    (pf.size_bytes <= $6 OR $6 IS NULL)
AND
    (uf.upload_date >= $7 OR $7 IS NULL)
AND
    (uf.upload_date <= $8 OR $8 IS NULL)
AND
    -- The @> operator checks if the tags array contains all elements from the input array.
    -- This is efficiently powered by our GIN index.
    (uf.tags @> $9::text[] OR $9 IS NULL)
AND
    -- Filter by a specific uploader's email if provided.
    (u.email = $10 OR $10 IS NULL)
ORDER BY
    uf.upload_date DESC
`

type SearchFilesParams struct {
	IsAdmin          bool
	RequestingUserID int64
	Filename         pgtype.Text
	MimeType         pgtype.Text
	MinSize          pgtype.Int8
	MaxSize          pgtype.Int8
	StartDate        pgtype.Timestamptz
	EndDate          pgtype.Timestamptz
	Tags             []string
	UploaderEmail    pgtype.Text
}

type SearchFilesRow struct {
	ID         int64
	Filename   string
	MimeType   string
	UploadDate pgtype.Timestamptz
	SizeBytes  int64
	OwnerEmail string
}

// Performs a comprehensive search and filter operation on user files.
// This query is optimized with indexes and uses sqlc.narg() for optional parameters.
func (q *Queries) SearchFiles(ctx context.Context, arg SearchFilesParams) ([]SearchFilesRow, error) {
	rows, err := q.db.Query(ctx, searchFiles,
		arg.IsAdmin,
		arg.RequestingUserID,
		arg.Filename,
		arg.MimeType,
		arg.MinSize,
		arg.MaxSize,
		arg.StartDate,
		arg.EndDate,
		arg.Tags,
		arg.UploaderEmail,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchFilesRow
	for rows.Next() {
		var i SearchFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.MimeType,
			&i.UploadDate,
			&i.SizeBytes,
			&i.OwnerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
