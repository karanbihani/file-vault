// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shares.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPublicShareLink = `-- name: CreatePublicShareLink :one
INSERT INTO shares (user_file_id, share_token) VALUES ($1, $2) RETURNING id, user_file_id, share_token, is_public, download_count, created_at
`

type CreatePublicShareLinkParams struct {
	UserFileID int64
	ShareToken string
}

func (q *Queries) CreatePublicShareLink(ctx context.Context, arg CreatePublicShareLinkParams) (Share, error) {
	row := q.db.QueryRow(ctx, createPublicShareLink, arg.UserFileID, arg.ShareToken)
	var i Share
	err := row.Scan(
		&i.ID,
		&i.UserFileID,
		&i.ShareToken,
		&i.IsPublic,
		&i.DownloadCount,
		&i.CreatedAt,
	)
	return i, err
}

const deletePublicShareLinksByFileID = `-- name: DeletePublicShareLinksByFileID :exec
DELETE FROM shares
WHERE user_file_id = $1
`

// Removes ALL public share links associated with a specific file.
func (q *Queries) DeletePublicShareLinksByFileID(ctx context.Context, userFileID int64) error {
	_, err := q.db.Exec(ctx, deletePublicShareLinksByFileID, userFileID)
	return err
}

const getPublicShareByFileID = `-- name: GetPublicShareByFileID :one
SELECT share_token, download_count
FROM shares
WHERE user_file_id = $1 AND is_public = TRUE
LIMIT 1
`

type GetPublicShareByFileIDRow struct {
	ShareToken    string
	DownloadCount pgtype.Int8
}

// Gets public share information for a file
func (q *Queries) GetPublicShareByFileID(ctx context.Context, userFileID int64) (GetPublicShareByFileIDRow, error) {
	row := q.db.QueryRow(ctx, getPublicShareByFileID, userFileID)
	var i GetPublicShareByFileIDRow
	err := row.Scan(&i.ShareToken, &i.DownloadCount)
	return i, err
}

const getShareByToken = `-- name: GetShareByToken :one
SELECT s.id, s.download_count, uf.filename, pf.storage_path, pf.size_bytes
FROM shares s
JOIN user_files uf ON s.user_file_id = uf.id
JOIN physical_files pf ON uf.physical_file_id = pf.id
WHERE s.share_token = $1 AND s.is_public = TRUE
`

type GetShareByTokenRow struct {
	ID            int64
	DownloadCount pgtype.Int8
	Filename      string
	StoragePath   string
	SizeBytes     int64
}

// CORRECTED NAME: Changed from GetShareMetaByToken for clarity and consistency.
func (q *Queries) GetShareByToken(ctx context.Context, shareToken string) (GetShareByTokenRow, error) {
	row := q.db.QueryRow(ctx, getShareByToken, shareToken)
	var i GetShareByTokenRow
	err := row.Scan(
		&i.ID,
		&i.DownloadCount,
		&i.Filename,
		&i.StoragePath,
		&i.SizeBytes,
	)
	return i, err
}

const getSharesForFile = `-- name: GetSharesForFile :many
SELECT u.id, u.email
FROM file_shares_to_users fstu
JOIN users u ON fstu.shared_with_user_id = u.id
WHERE fstu.user_file_id = $1
`

type GetSharesForFileRow struct {
	ID    int64
	Email string
}

// Retrieves all user shares for a specific file.
func (q *Queries) GetSharesForFile(ctx context.Context, userFileID int64) ([]GetSharesForFileRow, error) {
	rows, err := q.db.Query(ctx, getSharesForFile, userFileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharesForFileRow
	for rows.Next() {
		var i GetSharesForFileRow
		if err := rows.Scan(&i.ID, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementShareDownloadCount = `-- name: IncrementShareDownloadCount :exec
UPDATE shares SET download_count = download_count + 1 WHERE id = $1
`

func (q *Queries) IncrementShareDownloadCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementShareDownloadCount, id)
	return err
}

const isFileAlreadySharedWithUser = `-- name: IsFileAlreadySharedWithUser :one
SELECT EXISTS(
  SELECT 1 FROM file_shares_to_users
  WHERE user_file_id = $1 AND shared_with_user_id = $2
)
`

type IsFileAlreadySharedWithUserParams struct {
	UserFileID       int64
	SharedWithUserID int64
}

// Checks if a share record already exists to prevent duplicates.
func (q *Queries) IsFileAlreadySharedWithUser(ctx context.Context, arg IsFileAlreadySharedWithUserParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFileAlreadySharedWithUser, arg.UserFileID, arg.SharedWithUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const shareFileWithUser = `-- name: ShareFileWithUser :exec
INSERT INTO file_shares_to_users (
  user_file_id,
  shared_with_user_id
) VALUES (
  $1, $2
)
`

type ShareFileWithUserParams struct {
	UserFileID       int64
	SharedWithUserID int64
}

// Creates a record in the junction table to share a file with a specific user.
func (q *Queries) ShareFileWithUser(ctx context.Context, arg ShareFileWithUserParams) error {
	_, err := q.db.Exec(ctx, shareFileWithUser, arg.UserFileID, arg.SharedWithUserID)
	return err
}

const unshareFileWithUser = `-- name: UnshareFileWithUser :exec
DELETE FROM file_shares_to_users
WHERE user_file_id = $1 AND shared_with_user_id = $2
`

type UnshareFileWithUserParams struct {
	UserFileID       int64
	SharedWithUserID int64
}

// Removes a specific user's access to a shared file.
func (q *Queries) UnshareFileWithUser(ctx context.Context, arg UnshareFileWithUserParams) error {
	_, err := q.db.Exec(ctx, unshareFileWithUser, arg.UserFileID, arg.SharedWithUserID)
	return err
}
