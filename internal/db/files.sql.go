// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPhysicalFile = `-- name: CreatePhysicalFile :one
INSERT INTO physical_files (sha256_hash, size_bytes, storage_path) VALUES ($1, $2, $3) RETURNING id, sha256_hash, size_bytes, storage_path, reference_count, created_at
`

type CreatePhysicalFileParams struct {
	Sha256Hash  string
	SizeBytes   int64
	StoragePath string
}

func (q *Queries) CreatePhysicalFile(ctx context.Context, arg CreatePhysicalFileParams) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, createPhysicalFile, arg.Sha256Hash, arg.SizeBytes, arg.StoragePath)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.Sha256Hash,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const createUserFile = `-- name: CreateUserFile :one
INSERT INTO user_files (owner_id, physical_file_id, filename, mime_type, description, tags) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, owner_id, physical_file_id, filename, mime_type, description, tags, upload_date
`

type CreateUserFileParams struct {
	OwnerID        int64
	PhysicalFileID int64
	Filename       string
	MimeType       string
	Description    pgtype.Text
	Tags           []string
}

func (q *Queries) CreateUserFile(ctx context.Context, arg CreateUserFileParams) (UserFile, error) {
	row := q.db.QueryRow(ctx, createUserFile,
		arg.OwnerID,
		arg.PhysicalFileID,
		arg.Filename,
		arg.MimeType,
		arg.Description,
		arg.Tags,
	)
	var i UserFile
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PhysicalFileID,
		&i.Filename,
		&i.MimeType,
		&i.Description,
		&i.Tags,
		&i.UploadDate,
	)
	return i, err
}

const decrementPhysicalFileRefCount = `-- name: DecrementPhysicalFileRefCount :one
UPDATE physical_files SET reference_count = reference_count - 1 WHERE id = $1 RETURNING reference_count
`

func (q *Queries) DecrementPhysicalFileRefCount(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, decrementPhysicalFileRefCount, id)
	var reference_count int32
	err := row.Scan(&reference_count)
	return reference_count, err
}

const deletePhysicalFile = `-- name: DeletePhysicalFile :exec
DELETE FROM physical_files WHERE id = $1
`

func (q *Queries) DeletePhysicalFile(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePhysicalFile, id)
	return err
}

const deleteUserFile = `-- name: DeleteUserFile :exec
DELETE FROM user_files WHERE id = $1
`

func (q *Queries) DeleteUserFile(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUserFile, id)
	return err
}

const getFileForUserDownload = `-- name: GetFileForUserDownload :one
SELECT
    uf.filename,
    pf.storage_path,
    pf.size_bytes
FROM user_files uf
JOIN physical_files pf ON uf.physical_file_id = pf.id
WHERE
    uf.id = $1
    AND (
        uf.owner_id = $2
        OR
        EXISTS (
            SELECT 1 FROM file_shares_to_users fstu
            WHERE fstu.user_file_id = uf.id AND fstu.shared_with_user_id = $2
        )
    )
`

type GetFileForUserDownloadParams struct {
	FileID           int64
	RequestingUserID int64
}

type GetFileForUserDownloadRow struct {
	Filename    string
	StoragePath string
	SizeBytes   int64
}

// CORRECTED: Uses sqlc.arg() for explicit parameter naming.
func (q *Queries) GetFileForUserDownload(ctx context.Context, arg GetFileForUserDownloadParams) (GetFileForUserDownloadRow, error) {
	row := q.db.QueryRow(ctx, getFileForUserDownload, arg.FileID, arg.RequestingUserID)
	var i GetFileForUserDownloadRow
	err := row.Scan(&i.Filename, &i.StoragePath, &i.SizeBytes)
	return i, err
}

const getFileOwnerAndPhysicalFile = `-- name: GetFileOwnerAndPhysicalFile :one
SELECT uf.owner_id, pf.id as physical_file_id, pf.size_bytes, pf.storage_path
FROM user_files uf
JOIN physical_files pf ON uf.physical_file_id = pf.id
WHERE uf.id = $1 AND uf.owner_id = $2
`

type GetFileOwnerAndPhysicalFileParams struct {
	ID      int64
	OwnerID int64
}

type GetFileOwnerAndPhysicalFileRow struct {
	OwnerID        int64
	PhysicalFileID int64
	SizeBytes      int64
	StoragePath    string
}

// CORRECTED: Added pf.storage_path to the SELECT and uf.owner_id to the WHERE clause.
func (q *Queries) GetFileOwnerAndPhysicalFile(ctx context.Context, arg GetFileOwnerAndPhysicalFileParams) (GetFileOwnerAndPhysicalFileRow, error) {
	row := q.db.QueryRow(ctx, getFileOwnerAndPhysicalFile, arg.ID, arg.OwnerID)
	var i GetFileOwnerAndPhysicalFileRow
	err := row.Scan(
		&i.OwnerID,
		&i.PhysicalFileID,
		&i.SizeBytes,
		&i.StoragePath,
	)
	return i, err
}

const getPhysicalFileByHash = `-- name: GetPhysicalFileByHash :one
SELECT id, sha256_hash, size_bytes, storage_path, reference_count, created_at FROM physical_files WHERE sha256_hash = $1 LIMIT 1
`

// ... (all queries up to GetFileOwnerAndPhysicalFile are the same) ...
func (q *Queries) GetPhysicalFileByHash(ctx context.Context, sha256Hash string) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, getPhysicalFileByHash, sha256Hash)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.Sha256Hash,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const getUserFileForDownload = `-- name: GetUserFileForDownload :one
SELECT uf.id, uf.owner_id, uf.physical_file_id, uf.filename, uf.mime_type, uf.description, uf.tags, uf.upload_date, pf.storage_path FROM user_files uf JOIN physical_files pf ON uf.physical_file_id = pf.id WHERE uf.id = $1 AND uf.owner_id = $2
`

type GetUserFileForDownloadParams struct {
	ID      int64
	OwnerID int64
}

type GetUserFileForDownloadRow struct {
	ID             int64
	OwnerID        int64
	PhysicalFileID int64
	Filename       string
	MimeType       string
	Description    pgtype.Text
	Tags           []string
	UploadDate     pgtype.Timestamptz
	StoragePath    string
}

func (q *Queries) GetUserFileForDownload(ctx context.Context, arg GetUserFileForDownloadParams) (GetUserFileForDownloadRow, error) {
	row := q.db.QueryRow(ctx, getUserFileForDownload, arg.ID, arg.OwnerID)
	var i GetUserFileForDownloadRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PhysicalFileID,
		&i.Filename,
		&i.MimeType,
		&i.Description,
		&i.Tags,
		&i.UploadDate,
		&i.StoragePath,
	)
	return i, err
}

const incrementPhysicalFileRefCount = `-- name: IncrementPhysicalFileRefCount :one
UPDATE physical_files SET reference_count = reference_count + 1 WHERE id = $1 RETURNING id, sha256_hash, size_bytes, storage_path, reference_count, created_at
`

func (q *Queries) IncrementPhysicalFileRefCount(ctx context.Context, id int64) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, incrementPhysicalFileRefCount, id)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.Sha256Hash,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const isFileSharedWithUser = `-- name: IsFileSharedWithUser :one
SELECT EXISTS(
  SELECT 1 FROM file_shares_to_users
  WHERE user_file_id = $1 AND shared_with_user_id = $2
)
`

type IsFileSharedWithUserParams struct {
	UserFileID       int64
	SharedWithUserID int64
}

// Checks if a specific file has been shared with a specific user. Returns true or false.
func (q *Queries) IsFileSharedWithUser(ctx context.Context, arg IsFileSharedWithUserParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFileSharedWithUser, arg.UserFileID, arg.SharedWithUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listFilesSharedWithUser = `-- name: ListFilesSharedWithUser :many
SELECT uf.id, uf.owner_id, uf.physical_file_id, uf.filename, uf.mime_type, uf.description, uf.tags, uf.upload_date
FROM user_files uf
JOIN file_shares_to_users fstu ON uf.id = fstu.user_file_id
WHERE fstu.shared_with_user_id = $1
ORDER BY uf.upload_date DESC
`

// Retrieves a list of all files that have been explicitly shared with a specific user.
func (q *Queries) ListFilesSharedWithUser(ctx context.Context, sharedWithUserID int64) ([]UserFile, error) {
	rows, err := q.db.Query(ctx, listFilesSharedWithUser, sharedWithUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFile
	for rows.Next() {
		var i UserFile
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.PhysicalFileID,
			&i.Filename,
			&i.MimeType,
			&i.Description,
			&i.Tags,
			&i.UploadDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFiles = `-- name: ListUserFiles :many
SELECT id, owner_id, physical_file_id, filename, mime_type, description, tags, upload_date FROM user_files WHERE owner_id = $1 ORDER BY upload_date DESC
`

func (q *Queries) ListUserFiles(ctx context.Context, ownerID int64) ([]UserFile, error) {
	rows, err := q.db.Query(ctx, listUserFiles, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFile
	for rows.Next() {
		var i UserFile
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.PhysicalFileID,
			&i.Filename,
			&i.MimeType,
			&i.Description,
			&i.Tags,
			&i.UploadDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
